<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon Planificateur de Potager PRO (Rotation & Lignes) V6</title>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    
    <style>
        :root {
            --primary-green: #2e7d32;
            --hover-green: #1b5e20;
            --soil-color: #8D6E63;
            --bg-light: #f8f9fa;
            --text-dark: #2c3e50;
            --color-red: #e74c3c;
            --color-blue: #3498db;
            --color-yellow: #f1c40f;
            --barrier-color: #616161; /* Gris fonc√© pour les barri√®res */
            --jachere-color: #A4C6A4; /* Vert clair pour la jach√®re */
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg-light);
            margin: 0;
            padding: 20px;
            color: var(--text-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* Header Pro */
        .app-header {
            background: white;
            width: 100%;
            max-width: 1200px;
            padding: 15px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
            margin-bottom: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-green);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Conteneur principal */
        .main-container {
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            max-width: 1200px;
            width: 100%;
        }

        .info-bar {
            margin-bottom: 20px;
            padding: 15px;
            background: #e8f5e9;
            border-left: 4px solid var(--primary-green);
            border-radius: 4px;
            color: var(--primary-green);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .info-bar.history-tip {
             background: #f0f8ff;
             border-left-color: var(--color-blue);
             color: var(--color-blue);
        }

        /* OUTILS DE DESSIN */
        .drawing-tools {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        .drawing-tools button {
            padding: 10px 15px;
            border: 1px solid #ccc;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s, border-color 0.2s;
        }
        
        .drawing-tools button.active {
            background: var(--primary-green);
            color: white;
            border-color: var(--primary-green);
        }
        
        #toggleDrawModeBarrier {
            background: var(--barrier-color);
            color: white;
            border-color: var(--barrier-color);
        }

        /* ZONE STATISTIQUES GLOBALES */
        .stats-summary {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: #f4f4f4;
            border-radius: 8px;
        }
        .stat-card {
            text-align: center;
            padding: 10px 20px;
            border-right: 1px solid #ddd;
        }
        .stat-card:last-child {
            border-right: none;
        }
        .stat-card strong {
            display: block;
            font-size: 1.5rem;
            color: var(--primary-green);
        }
        .stat-card small {
            font-size: 0.9rem;
            color: #666;
        }

        /* NOUVELLE DISPOSITION FLEXIBLE */
        .garden-layout {
            display: flex;
            gap: 20px;
            width: 100%;
        }

        /* ZONE DE DESSIN (Canvas) */
        #garden-canvas {
            flex: 2; /* Le potager prend plus d'espace */
            min-width: 60%;
            height: 600px; 
            background-color: var(--soil-color);
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23000000' fill-opacity='0.05' fill-rule='evenodd'%3E%3Cpath d='M0 40L40 0H20L0 20M40 40V20L20 40'/%3E%3C/g%3E%3C/path%3E%3C/svg%3E");
            border-radius: 12px;
            border: 8px solid #6D4C41; 
            position: relative;
            cursor: crosshair;
            overflow: hidden;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.3);
            user-select: none;
        }

        /* LES PLANCHES DESSIN√âES */
        .garden-element {
            position: absolute;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.3);
            font-size: 14px;
            overflow: hidden;
            word-break: break-word;
            border-radius: 4px;
            transition: transform 0.1s, box-shadow 0.1s;
            user-select: none;
        }
        
        /* Styles pour les planches de culture (BED) */
        .garden-bed {
            border: 2px solid rgba(255, 255, 255, 0.7);
            color: white;
            font-weight: 700;
            display: flex;
            flex-direction: column; 
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 8px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            line-height: 1.2;
            cursor: pointer;
            background-color: transparent; /* N√©cessaire pour le motif */
        }

        .garden-bed:hover {
             transform: scale(1.02);
             z-index: 100;
             border-color: white;
             box-shadow: 5px 5px 15px rgba(0,0,0,0.4);
        }

        /* Style sp√©cifique pour la JACH√àRE (Hachur√©) */
        .garden-bed.is-jachere {
            background-color: var(--jachere-color) !important;
            background-image: linear-gradient(45deg, rgba(255,255,255,.2) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.2) 50%, rgba(255,255,255,.2) 75%, transparent 75%, transparent);
            background-size: 15px 15px;
        }
        
        /* Le contenu de la planche doit √™tre transparent si la planche est hachur√©e (pour laisser voir le hachurage) */
        .garden-bed.is-jachere .bed-content {
            background-color: transparent !important;
        }

        .garden-bed .bed-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* Styles pour les BARRI√àRES (LIGNES) */
        .garden-line {
            position: absolute;
            height: 5px; /* √âpaisseur de la ligne */
            background-color: var(--barrier-color);
            border-radius: 2px;
            transform-origin: 0 0; /* Important pour la rotation */
            box-shadow: 1px 1px 5px rgba(0,0,0,0.4);
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: white;
            padding: 0 10px;
        }
        
        .garden-line:hover {
            opacity: 0.8;
            cursor: grab;
        }

        /* Poign√©es de redimensionnement/d√©placement pour les lignes */
        .line-handle {
            width: 12px;
            height: 12px;
            background: var(--primary-green);
            border: 2px solid white;
            position: absolute;
            border-radius: 50%;
            z-index: 150;
            cursor: grab;
        }
        /* Ajustements de position pour que les poign√©es soient centr√©es sur la ligne de 5px */
        .line-handle.start { left: -6px; top: -3.5px; } 
        .line-handle.end { right: -6px; top: -3.5px; }

        /* Le rectangle fant√¥me */
        #ghost-rect {
            position: absolute;
            border: 2px dashed rgba(255,255,255,0.8);
            background-color: rgba(255, 255, 255, 0.2);
            pointer-events: none;
            display: none;
            z-index: 50;
        }
        
        /* Resizer styles pour les planches (BED) */
        .resizer {
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid var(--primary-green);
            position: absolute;
            z-index: 150;
            border-radius: 50%;
            opacity: 0.8;
        }
        .resizer.bottom-right { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .resizer.bottom-left { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .resizer.top-right { top: -6px; right: -6px; cursor: nesw-resize; }
        .resizer.top-left { top: -6px; left: -6px; cursor: nwse-resize; }

        /* --- MODAL STYLING (FEN√äTRE MODIFICATION) --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 350px;
            display: flex;
            flex-direction: column;
            max-height: 90vh; 
            overflow-y: auto; 
        }

        .modal-content h4 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .modal-content label {
            font-weight: 600;
            margin-top: 10px;
            margin-bottom: 5px;
            display: block;
        }

        .modal-content input:not([type="color"]):not([type="radio"]):not([type="checkbox"]), 
        .modal-content select, 
        .modal-content textarea {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
            margin-top: 5px;
        }

        .modal-content textarea {
            min-height: 80px;
        }
        
        .icon-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .icon-selector input[type="radio"] {
            display: none;
        }
        
        .icon-selector label {
            cursor: pointer;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1.2rem;
            transition: all 0.2s;
            margin-top: 0;
        }
        
        .icon-selector input[type="radio"]:checked + label {
            background-color: var(--primary-green);
            color: white;
            border-color: var(--primary-green);
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .modal-actions button {
            padding: 10px 15px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            flex-grow: 1;
            transition: background 0.2s;
        }

        #saveBtn, #saveBarrierBtn {
            background: var(--primary-green);
            color: white;
        }
        #saveBtn:hover, #saveBarrierBtn:hover {
            background: var(--hover-green);
        }

        .new-culture {
            background: var(--color-blue);
            color: white;
        }
        .new-culture:hover {
            background: #2980b9;
        }

        .delete {
            background: var(--color-red);
            color: white;
        }
        .delete:hover {
            background: #c0392b;
        }

        .cancel {
            background: #ccc;
            color: var(--text-dark);
        }
        .cancel:hover {
            background: #bbb;
        }

        .modal-stats {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #666;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .input-group input {
            flex-grow: 1;
        }
        .unit-select select {
            width: auto;
            min-width: 100px;
        }
        
        /* Styles pour la modale BARRIER (Ligne) */
        #barrierModal .modal-content {
            width: 300px;
        }

        /* Styles pour l'historique et le calendrier */
        #planningCalendar, #rotationAdvice, .sidebar {
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 20px;
            flex: 1;
            width: 100%;
            box-sizing: border-box;
        }
        
        #planningCalendar h3, #rotationAdvice h3 {
            color: var(--primary-green);
            margin-top: 0;
            padding-bottom: 5px;
            border-bottom: 1px dashed #eee;
        }

        #calendarList, #historyList {
            list-style: none;
            padding: 0;
        }

        .calendar-item, .history-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #f9f9f9;
            border-radius: 4px;
            border-left: 5px solid #ccc;
            font-size: 0.9rem;
            line-height: 1.4;
            display: flex;
            flex-direction: column;
        }
        
        .calendar-item strong, .history-item-header {
            font-size: 1rem;
            margin-bottom: 2px;
        }
        
        .advice-item {
            padding: 8px;
            border-left: 4px solid #ccc;
            margin: 5px 0;
            background: #fcfcfc;
            border-radius: 4px;
        }
        .advice-ok { border-color: var(--primary-green); color: var(--primary-green); font-weight: 600; }
        .advice-warning { border-color: var(--color-yellow); color: var(--color-yellow); font-weight: 600; }
        .advice-danger { border-color: var(--color-red); color: var(--color-red); font-weight: 600; }
        
        /* Jach√®re Checkbox */
        .jachere-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background: #efffef;
            border: 1px solid var(--primary-green);
            border-radius: 4px;
            cursor: pointer;
        }
        .jachere-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }
        .jachere-group label {
            margin: 0;
            cursor: pointer;
            font-weight: 700;
            color: var(--primary-green);
        }

    </style>
</head>
<body>

    <header class="app-header">
        <div class="logo">
            <i class="ri-plant-fill"></i> Mon Potager Pro
        </div>
        
        <div class="stats-summary" id="statsSummary">
            </div>

    </header>

    <div class="main-container">
        
        <div class="drawing-tools">
             <button id="toggleDrawMode" class="active" data-mode="bed">
                <i class="ri-seedling-line"></i> Dessiner une Planche
            </button>
            <button id="toggleDrawModeBarrier" data-mode="barrier">
                <i class="ri-ruler-line"></i> Tracer une Barri√®re/All√©e (Ligne)
            </button>
        </div>
        
        <div class="info-bar history-tip">
            <i class="ri-information-fill"></i>
            <span>**Clique simple** sur une planche pour voir son historique de rotation. **Double-clic** pour √©diter.</span>
        </div>

        <div class="filter-controls">
            <label for="dateFilter">Voir le potager au :</label>
            <input type="date" id="dateFilter">
        </div>

        <div class="garden-layout"> 
            <div id="garden-canvas">
                <div id="ghost-rect"></div>
            </div>
            
            <div class="sidebar-container">
                <div id="planningCalendar">
                    <h3>üóìÔ∏è √âch√©ancier Futur</h3>
                    <ul id="calendarList">
                        </ul>
                </div>

                <div id="rotationAdvice">
                    <h3>‚ôªÔ∏è Recommandation de Rotation</h3>
                    <div id="adviceContent">
                        <p>S√©lectionnez une planche pour afficher les conseils de rotation.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="editModal" class="modal-overlay">
        <div class="modal-content">
            <h4>Modifier la Planche de Culture</h4>
            <input type="hidden" id="modalBedId">
            <input type="hidden" id="modalIconValue"> 
            <input type="hidden" id="modalLocationKey"> 
            
            <label for="modalName">Nom de la culture :</label>
            <input type="text" id="modalName">
            
            <div class="jachere-group">
                <input type="checkbox" id="modalIsJachere">
                <label for="modalIsJachere">Jach√®re active / Engrais Vert</label>
            </div>
            
            <label for="modalFamily">Famille de culture :</label>
            <select id="modalFamily">
                </select>
            
            <label for="modalVariety">Vari√©t√© :</label>
            <input type="text" id="modalVariety" placeholder="Ex: C≈ìur de B≈ìuf">

            <label for="modalColor">Couleur :</label>
            <input type="color" id="modalColor" value="#4CAF50">

            <label>Ic√¥ne de culture :</label>
            <div id="iconSelector" class="icon-selector">
                </div>

            <label for="modalSeedsPlants">Qt√© de semences / plants :</label>
            <input type="number" id="modalSeedsPlants" min="0" placeholder="Nombre de pieds, grammes, etc.">

            <label for="modalPlantingDate">Date de plantation :</label>
            <input type="date" id="modalPlantingDate">

            <label for="modalHarvestDate">Date d'arrachage pr√©vue :</label>
            <input type="date" id="modalHarvestDate">
            
            <label for="modalStage">√âtape de Culture Actuelle :</label>
            <select id="modalStage">
                </select>
            
            <label for="modalHarvestedQuantity">R√©colte r√©elle :</label>
            <div class="input-group">
                <div>
                    <input type="number" id="modalHarvestedQuantity" min="0" placeholder="Quantit√©">
                </div>
                <div class="unit-select">
                    <select id="modalUnit">
                        </select>
                </div>
            </div>

            <label for="modalNotes">Notes de culture :</label>
            <textarea id="modalNotes" placeholder="Performance, fertilisation, probl√®mes..."></textarea>
            
            <div class="modal-stats">
                Dimensions (pixels) : <span id="modalDimensions"></span>
            </div>
            
            <div class="modal-actions">
                <button id="saveBtn">Sauvegarder</button>
                <button id="newCultureBtn" class="new-culture">Nouvelle Culture (Archiver)</button> 
                <button id="deleteBtn" class="delete">Supprimer</button>
                <button id="closeModalBtn" class="cancel">Annuler</button>
            </div>
        </div>
    </div>
    
    <div id="barrierModal" class="modal-overlay">
        <div class="modal-content">
            <h4>Modifier la Barri√®re/All√©e</h4>
            <input type="hidden" id="modalBarrierId">
            <label for="modalBarrierName">Nom de la Barri√®re :</label>
            <input type="text" id="modalBarrierName" placeholder="Ex: All√©e centrale">
            <div class="modal-stats">
                Longueur (pixels) : <span id="modalBarrierLength"></span>
            </div>
            <div class="modal-actions">
                <button id="saveBarrierBtn">Sauvegarder</button>
                <button id="deleteBarrierBtn" class="delete">Supprimer</button>
                <button id="closeBarrierModalBtn" class="cancel">Annuler</button>
            </div>
        </div>
    </div>

    <div id="historyModal" class="modal-overlay">
        <div class="modal-content">
            <h4 id="historyTitle">Historique de la Planche</h4>
            <ul id="historyList">
                </ul>
            <div class="modal-actions">
                <button id="closeHistoryBtn" class="cancel">Fermer</button>
            </div>
        </div>
    </div>


    <script>
        /* ======================================= */
        /* --- LOGIQUE JAVASCRIPT --- */
        /* ======================================= */

        // 1. √âTAT DE L'APPLICATION (La m√©moire)
        let appState = {
            allBeds: [], 
            drawMode: 'bed' // 'bed' ou 'line'
        };

        // Donn√©es d'ic√¥nes, de familles et unit√©s
        const ICON_MAP = {
            'Carotte ü•ï': 'ri-carrot-line',
            'Tomate üçÖ': 'ri-plant-line',
            'Laitue ü•¨': 'ri-leaf-line',
            'Fleur üå∏': 'ri-flower-line',
            'Graine üå±': 'ri-seedling-line',
            'Ail üßÑ': 'ri-onion-line',
            'Fruit üçé': 'ri-apple-line',
            'Jach√®re': 'ri-grass-line' 
        };
        
        // --- FAMILLES DE CULTURE (Pour le s√©lecteur) ---
        const CROP_FAMILIES = {
            '': '--- Famille (Rotation) ---',
            'Solanac√©es': 'Tomates, Poivrons, Aubergines, Pommes de terre (Gourmands)',
            'Cucurbitac√©es': 'Courges, Concombres, Courgettes (Gourmands)',
            'L√©gumineuses': 'Haricots, Pois, F√®ves (Am√©liorantes, Fixation N)',
            'Alliac√©es': 'Ail, Oignon, √âchalotes, Poireaux (Nettoyantes)',
            'Brassicac√©es': 'Choux, Radis, Navets, Moutarde',
            'Ast√©rac√©es': 'Laitues, Chicor√©es, Artichauts',
            'Ch√©nopodiac√©es': 'Bettes, √âpinards',
            'Ombellif√®res': 'Carottes, C√©leris, Persil',
            'Autre': 'Culture ne n√©cessitant pas de rotation stricte' 
        };
        
        const JACHERE_FAMILY_KEY = 'Jach√®re/Engrais Vert'; // Cl√© interne pour la rotation

        // --- R√àGLES DE ROTATION (4 ans) ---
        const ROTATION_RULES = {
            'Solanac√©es': { 
                avoid: ['Solanac√©es', 'Cucurbitac√©es', 'Brassicac√©es'], 
                follow: ['L√©gumineuses', JACHERE_FAMILY_KEY, 'Alliac√©es'] 
            },
            'Cucurbitac√©es': { 
                avoid: ['Cucurbitac√©es', 'Solanac√©es'], 
                follow: ['L√©gumineuses', JACHERE_FAMILY_KEY, 'Ombellif√®res'] 
            },
            'Ombellif√®res': { 
                avoid: ['Ombellif√®res'], 
                follow: ['Brassicac√©es', 'Alliac√©es', 'L√©gumineuses', 'Ast√©rac√©es'] 
            },
            'Brassicac√©es': { 
                avoid: ['Brassicac√©es', 'Solanac√©es'], 
                follow: ['L√©gumineuses', 'Ast√©rac√©es', 'Ombellif√®res', 'Alliac√©es'] 
            },
            'L√©gumineuses': { 
                avoid: ['L√©gumineuses'], 
                follow: ['Solanac√©es', 'Cucurbitac√©es', 'Ombellif√®res', 'Brassicac√©es'] 
            },
            'Alliac√©es': { 
                avoid: ['Alliac√©es'], 
                follow: ['L√©gumineuses', 'Ast√©rac√©es', 'Ombellif√®res', 'Ch√©nopodiac√©es', 'Brassicac√©es'] 
            },
            [JACHERE_FAMILY_KEY]: { // R√®gle pour la jach√®re
                avoid: [], 
                follow: ['Solanac√©es', 'Cucurbitac√©es', 'L√©gumineuses', 'Alliac√©es', 'Brassicac√©es', 'Ombellif√®res', 'Ast√©rac√©es', 'Ch√©nopodiac√©es'] 
            },
            'Autre': {
                avoid: [],
                follow: ['L√©gumineuses', 'Ast√©rac√©es', 'Ombellif√®res']
            }
        };

        const HARVEST_UNITS = [
            '--- Unit√© ---', 'kg', 'g', 'L', 'mL', 'pieds', 't√™tes', 'pi√®ces', 'mottes', 'sachets'
        ];
        
        const CROP_STAGES = [
            'Semis en place',
            'Semis en p√©pini√®re',
            'Plantation',
            'Croissance',
            'Floraison',
            'Fructification',
            'R√©colte en cours',
            'Arrachage/Fin'
        ];

        // Variables de dessin et redimensionnement
        let isDrawing = false;
        let isResizing = false;
        let isMovingLine = false;
        let clickTimeout = null; 
        let startX, startY;
        let activeElement = null; // Peut √™tre bed ou line
        let resizeHandleType = '';

        // √âl√©ments du DOM 
        const canvas = document.getElementById('garden-canvas');
        const ghostRect = document.getElementById('ghost-rect');
        const dateFilter = document.getElementById('dateFilter');
        const editModal = document.getElementById('editModal');
        const modalBedId = document.getElementById('modalBedId');
        const modalName = document.getElementById('modalName');
        const modalIsJachere = document.getElementById('modalIsJachere'); 
        const modalVariety = document.getElementById('modalVariety');
        const modalFamily = document.getElementById('modalFamily');
        const modalColor = document.getElementById('modalColor');
        const modalIconValue = document.getElementById('modalIconValue');
        const iconSelector = document.getElementById('iconSelector');
        const modalSeedsPlants = document.getElementById('modalSeedsPlants');
        const modalPlantingDate = document.getElementById('modalPlantingDate');
        const modalHarvestDate = document.getElementById('modalHarvestDate');
        const modalStage = document.getElementById('modalStage'); 
        const modalHarvestedQuantity = document.getElementById('modalHarvestedQuantity');
        const modalUnit = document.getElementById('modalUnit');
        const modalNotes = document.getElementById('modalNotes');
        const modalDimensions = document.getElementById('modalDimensions');
        const historyModal = document.getElementById('historyModal');
        const rotationAdvice = document.getElementById('rotationAdvice');
        const adviceContent = document.getElementById('adviceContent');
        const statsSummary = document.getElementById('statsSummary');
        const calendarList = document.getElementById('calendarList');
        const historyList = document.getElementById('historyList');
        const historyTitle = document.getElementById('historyTitle');
        const toggleDrawModeBtn = document.getElementById('toggleDrawMode');
        const toggleDrawModeBarrierBtn = document.getElementById('toggleDrawModeBarrier');
        const barrierModal = document.getElementById('barrierModal');
        const modalBarrierId = document.getElementById('modalBarrierId');
        const modalBarrierName = document.getElementById('modalBarrierName');
        const modalBarrierLength = document.getElementById('modalBarrierLength');


        // --- INITIALISATION et Helpers ---
        function init() {
            const savedData = localStorage.getItem('potagerProData');
            if (savedData) {
                try {
                    const loadedData = JSON.parse(savedData);
                    appState.allBeds = loadedData.map(item => ({
                        ...item,
                        type: item.type || 'bed', 
                        isJachere: item.isJachere || (item.family === JACHERE_FAMILY_KEY), 
                        family: item.isJachere ? '' : item.family, // Enlever la famille Jach√®re si c'est g√©r√© par le flag
                        seeds_plants: item.seeds_plants || '',
                        harvested_quantity: item.harvested_quantity || '',
                        unit: item.unit || '',
                        stage: item.stage || CROP_STAGES[3],
                        notes: item.notes || '',
                        // Pour les lignes, assurer que le champ 'points' existe
                        points: item.type === 'line' ? item.points : undefined,
                    }));
                } catch (e) {
                    appState.allBeds = []; 
                }
            }
            dateFilter.value = new Date().toISOString().split('T')[0]; 
            generateIconSelector();
            generateFamilySelector(); 
            generateUnitSelector(); 
            generateStageSelector(); 
            setupEventListeners();
            render(); 
        }
        
        function normalizeFamily(family) {
            return family === JACHERE_FAMILY_KEY ? JACHERE_FAMILY_KEY : (family in CROP_FAMILIES ? family : 'Autre');
        }
        
        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            const date = new Date(dateString);
            return date.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short', year: 'numeric' });
        }

        function generateDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function saveData() {
            const cleanData = appState.allBeds.map(item => {
                // Suppression des propri√©t√©s temporaires de redimensionnement
                const { initialX, initialY, initialW, initialH, initialP0, initialP1, ...rest } = item;
                return rest;
            });
            localStorage.setItem('potagerProData', JSON.stringify(cleanData));
        }
        
        function getLocationKey(element) {
             if (element.type === 'line') {
                const p0 = element.points[0];
                const p1 = element.points[1];
                // Cl√© bas√©e sur la position tri√©e pour l'unicit√©
                const points = [p0, p1].sort((a, b) => (a.x + a.y) - (b.x + b.y)); 
                return `${points[0].x}_${points[0].y}_${points[1].x}_${points[1].y}_line`;
             }
             // Cl√© pour la rotation des planches
             return `${element.x}_${element.y}_${element.w}_${element.h}_bed`;
        }


        // --- FONCTIONS DE MODALE/UI ---

        function generateIconSelector() {
            iconSelector.innerHTML = '';
            Object.entries(ICON_MAP).forEach(([name, iconClass]) => {
                const id = `icon-${iconClass}`;
                const input = document.createElement('input');
                input.type = 'radio';
                input.id = id;
                input.name = 'icon-selector';
                input.value = iconClass;
                
                const label = document.createElement('label');
                label.htmlFor = id;
                label.innerHTML = `<i class="${iconClass}"></i> ${name}`;
                
                input.addEventListener('change', () => modalIconValue.value = iconClass);
                
                iconSelector.appendChild(input);
                iconSelector.appendChild(label);
            });
        }
        
        function generateFamilySelector() {
            modalFamily.innerHTML = '';
            Object.entries(CROP_FAMILIES).forEach(([key, description]) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key || description;
                modalFamily.appendChild(option);
            });
        }
        
        function generateUnitSelector() {
            modalUnit.innerHTML = '';
            HARVEST_UNITS.forEach(unit => {
                const option = document.createElement('option');
                option.value = unit;
                option.textContent = unit;
                modalUnit.appendChild(option);
            });
        }
        
        function generateStageSelector() {
            modalStage.innerHTML = '';
            CROP_STAGES.forEach(stage => {
                const option = document.createElement('option');
                option.value = stage;
                option.textContent = stage;
                modalStage.appendChild(option);
            });
        }

        // Fonctions Modales de Culture (BED)
        function openModal(bed) {
            activeElement = bed;
            modalBedId.value = bed.id;
            modalName.value = bed.name;
            modalIsJachere.checked = bed.isJachere || false;
            modalVariety.value = bed.variety || '';
            // Si la famille est Jach√®re, on remet le select √† vide pour √©viter la confusion
            modalFamily.value = bed.family === JACHERE_FAMILY_KEY ? '' : bed.family || ''; 
            modalColor.value = bed.color;
            modalPlantingDate.value = bed.plantingDate || new Date().toISOString().split('T')[0];
            modalHarvestDate.value = bed.harvestDate || '';
            modalStage.value = bed.stage || CROP_STAGES[3]; 
            modalNotes.value = bed.notes || '';
            modalSeedsPlants.value = bed.seeds_plants || ''; 
            modalHarvestedQuantity.value = bed.harvested_quantity || '';
            modalUnit.value = bed.unit || HARVEST_UNITS[0]; 
            modalDimensions.textContent = `${bed.w} x ${bed.h} px`;
            
            // Gestion de l'ic√¥ne
            const currentIconRadio = iconSelector.querySelector(`input[value="${bed.icon}"]`);
            iconSelector.querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = false);
            if (currentIconRadio) {
                currentIconRadio.checked = true;
                modalIconValue.value = bed.icon;
            } else {
                modalIconValue.value = ''; 
            }
            editModal.style.display = 'flex';
        }

        function closeModal() {
            editModal.style.display = 'none';
            activeElement = null;
        }

        // Fonctions Modales d'Historique
        function openHistoryModal(bed) {
            const allHistory = appState.allBeds
                .filter(b => b.locationKey === bed.locationKey && b.type === 'bed')
                .sort((a, b) => new Date(b.plantingDate) - new Date(a.plantingDate)); // Triage anti-chronologique

            historyTitle.textContent = `Historique de rotation pour: ${bed.name || 'Planche sans nom'} (${bed.w}x${bed.h} px)`;
            historyList.innerHTML = '';

            if (allHistory.length === 0) {
                historyList.innerHTML = '<li class="history-item">Aucun historique trouv√© pour cet emplacement.</li>';
            } else {
                allHistory.forEach((item, index) => {
                    // Si c'est l'entr√©e actuelle et qu'elle n'est pas encore finie
                    const isCurrent = (index === 0 && !item.harvestDate); 

                    const li = document.createElement('li');
                    li.className = 'history-item';
                    if (isCurrent) li.style.borderLeftColor = 'var(--color-blue)';
                    
                    const familyDisplay = item.isJachere ? JACHERE_FAMILY_KEY : normalizeFamily(item.family);
                    const familyDescription = CROP_FAMILIES[familyDisplay] || (familyDisplay === JACHERE_FAMILY_KEY ? 'Am√©liorant' : 'N/A');

                    li.innerHTML = `
                        <strong class="history-item-header">${item.name || 'Culture sans nom'} ${item.variety ? `(${item.variety})` : ''}</strong>
                        <span><i class="ri-seedling-line"></i> **Famille:** ${familyDisplay} (${familyDescription})</span>
                        <span><i class="ri-calendar-check-line"></i> **Plantation:** ${formatDate(item.plantingDate)}</span>
                        <span><i class="ri-calendar-close-line"></i> **Arrachage:** ${formatDate(item.harvestDate)} ${isCurrent ? '(Culture Actuelle)' : ''}</span>
                        ${item.harvested_quantity ? `<span><i class="ri-archive-line"></i> **R√©colte:** ${item.harvested_quantity} ${item.unit}</span>` : ''}
                    `;
                    historyList.appendChild(li);
                });
            }

            historyModal.style.display = 'flex';
        }
        
        function closeHistoryModal() {
            historyModal.style.display = 'none';
        }

        // Fonctions Modales de Barri√®re (LIGNE)
        function openBarrierModal(line) {
            activeElement = line;
            modalBarrierId.value = line.id;
            modalBarrierName.value = line.name || '';
            const { length } = calculateLineStyle(line.points[0].x, line.points[0].y, line.points[1].x, line.points[1].y);
            modalBarrierLength.textContent = `${length.toFixed(2)} px`;
            barrierModal.style.display = 'flex';
        }

        function closeBarrierModal() {
            barrierModal.style.display = 'none';
            activeElement = null;
        }

        // --- GESTION DES √âV√âNEMENTS ---
        function setupEventListeners() {
            // √âv√©nements des Modales
            document.getElementById('closeHistoryBtn').addEventListener('click', closeHistoryModal);
            document.getElementById('saveBtn').addEventListener('click', saveModification);
            document.getElementById('newCultureBtn').addEventListener('click', addNewCulture); 
            document.getElementById('deleteBtn').addEventListener('click', deleteBed);
            document.getElementById('closeModalBtn').addEventListener('click', closeModal);
            editModal.addEventListener('click', (e) => {
                if (e.target === editModal) closeModal();
            });
            
            // √âv√©nements des Modales de Barri√®re (Ligne)
            document.getElementById('closeBarrierModalBtn').addEventListener('click', closeBarrierModal);
            document.getElementById('saveBarrierBtn').addEventListener('click', saveBarrierModification);
            document.getElementById('deleteBarrierBtn').addEventListener('click', deleteBarrier);
            barrierModal.addEventListener('click', (e) => {
                if (e.target === barrierModal) closeBarrierModal();
            });

            // √âv√©nement Filtre de Date 
            dateFilter.addEventListener('change', render);
            
            // √âv√©nements de bascule de mode de dessin
            toggleDrawModeBtn.addEventListener('click', () => setDrawMode('bed'));
            toggleDrawModeBarrierBtn.addEventListener('click', () => setDrawMode('line'));
            
            // √âv√©nement d'ic√¥ne (correction pour que l'ic√¥ne de jach√®re soit forc√©e si coch√©e)
             modalIsJachere.addEventListener('change', () => {
                if (modalIsJachere.checked) {
                    modalName.value = 'Jach√®re/Engrais Vert';
                    modalFamily.value = '';
                    const jachereIcon = ICON_MAP['Jach√®re'];
                    modalIconValue.value = jachereIcon;
                    iconSelector.querySelectorAll('input[type="radio"]').forEach(radio => {
                        radio.checked = radio.value === jachereIcon;
                    });
                }
            });


            // DESSIN : Mousedown
            canvas.addEventListener('mousedown', (e) => {
                const targetEl = e.target.closest('.garden-element');
                
                // 1. Gestion du redimensionnement/d√©placement des √©l√©ments existants
                if (e.target.closest('.resizer')) {
                    startResizeBed(e);
                    return;
                } 
                if (e.target.closest('.line-handle') || (targetEl && targetEl.classList.contains('garden-line'))) {
                    startMoveOrResizeLine(e);
                    return;
                } 

                // 2. D√©marrer le dessin d'un nouvel √©l√©ment
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
                
                if (appState.drawMode === 'bed') {
                    // Pour la planche (rectangle fant√¥me)
                    ghostRect.style.left = `${startX}px`;
                    ghostRect.style.top = `${startY}px`;
                    ghostRect.style.width = '0px';
                    ghostRect.style.height = '0px';
                    ghostRect.style.display = 'block';
                    ghostRect.style.borderColor = 'rgba(255, 255, 255, 0.8)';
                    ghostRect.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                } else if (appState.drawMode === 'line') {
                     // Pour la ligne, pas de rectangle fant√¥me, mais on pr√©pare
                }
            });

            // MOUVEMENT ET REDIMENSIONNEMENT : Mousemove
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                if (isResizing) {
                    performResizeBed(currentX, currentY);
                } else if (isMovingLine) {
                    performMoveOrResizeLine(currentX, currentY);
                } else if (isDrawing && appState.drawMode === 'bed') {
                    // Dessin de planche
                    const width = Math.abs(currentX - startX);
                    const height = Math.abs(currentY - startY);
                    const posX = Math.min(startX, currentX);
                    const posY = Math.min(startY, currentY);
                    ghostRect.style.left = `${posX}px`;
                    ghostRect.style.top = `${posY}px`;
                    ghostRect.style.width = `${width}px`;
                    ghostRect.style.height = `${height}px`;
                }
            });

            // FIN : Mouseup
            canvas.addEventListener('mouseup', (e) => {
                const rect = canvas.getBoundingClientRect();
                const finalX = e.clientX - rect.left;
                const finalY = e.clientY - rect.top;

                if (isDrawing) {
                    isDrawing = false;
                    ghostRect.style.display = 'none';

                    if (appState.drawMode === 'bed') {
                        const finalW = Math.abs(finalX - startX);
                        const finalH = Math.abs(finalY - startY);
                        const posX = Math.min(startX, finalX);
                        const posY = Math.min(startY, finalY);
                        if(finalW < 30 || finalH < 30) return;
                        createBed(posX, posY, finalW, finalH);
                    } else if (appState.drawMode === 'line') {
                        // Trac√© de ligne
                        const distance = generateDistance(startX, startY, finalX, finalY);
                        if (distance > 10) { // Longueur minimale de 10px pour une ligne
                             createLine(startX, startY, finalX, finalY);
                        }
                    }
                }
                
                if (isResizing || isMovingLine) {
                    if (activeElement) {
                        activeElement.locationKey = getLocationKey(activeElement);
                        saveData();
                    }
                    isResizing = false;
                    isMovingLine = false;
                    activeElement = null;
                    resizeHandleType = '';
                    render(); 
                }
            });
        }
        
        function setDrawMode(mode) {
             appState.drawMode = mode;
             toggleDrawModeBtn.classList.remove('active');
             toggleDrawModeBarrierBtn.classList.remove('active');
             
             if (mode === 'bed') {
                 toggleDrawModeBtn.classList.add('active');
             } else { // 'line'
                 toggleDrawModeBarrierBtn.classList.add('active');
             }
        }
        
        // --- LOGIQUE METIER (Sauvegardes / Rotations) ---

        function saveModification() {
            const bed = appState.allBeds.find(b => b.id === parseInt(modalBedId.value) && b.type === 'bed');
            if (bed) {
                const isJachere = modalIsJachere.checked;
                
                bed.name = modalName.value.trim();
                bed.isJachere = isJachere; 
                bed.variety = modalVariety.value.trim();

                // Gestion de la famille pour la rotation
                bed.family = isJachere ? JACHERE_FAMILY_KEY : modalFamily.value; 
                
                bed.color = modalColor.value;
                if (isJachere) {
                    bed.name = bed.name || 'Jach√®re/Engrais Vert';
                    bed.icon = ICON_MAP['Jach√®re'];
                } else {
                    bed.icon = modalIconValue.value;
                }
                
                bed.plantingDate = modalPlantingDate.value;
                bed.harvestDate = modalHarvestDate.value;
                bed.stage = modalStage.value; 
                bed.notes = modalNotes.value.trim();
                bed.seeds_plants = modalSeedsPlants.value;
                bed.harvested_quantity = modalHarvestedQuantity.value;
                bed.unit = modalUnit.value;
                bed.locationKey = getLocationKey(bed); 
                
                saveData();
                render();
                closeModal(); 
            }
        }
        
        function saveBarrierModification() {
            const line = appState.allBeds.find(b => b.id === parseInt(modalBarrierId.value) && b.type === 'line');
            if (line) {
                line.name = modalBarrierName.value.trim();
                // La locationKey est mise √† jour apr√®s le d√©placement/redimensionnement
                saveData();
                render();
                closeBarrierModal();
            }
        }
        
        function deleteBed() {
            if (confirm("√ätes-vous s√ªr de vouloir supprimer cette planche de culture ?")) {
                const bedId = parseInt(modalBedId.value);
                appState.allBeds = appState.allBeds.filter(b => b.id !== bedId);
                saveData();
                render();
                closeModal();
            }
        }
        
        function deleteBarrier() {
            if (confirm("√ätes-vous s√ªr de vouloir supprimer cette barri√®re/all√©e ?")) {
                const barrierId = parseInt(modalBarrierId.value);
                appState.allBeds = appState.allBeds.filter(b => b.id !== barrierId);
                saveData();
                render();
                closeBarrierModal();
            }
        }
        
        /**
         * Archive la culture actuelle et cr√©e une nouvelle entr√©e pour la nouvelle culture/jach√®re.
         */
        function addNewCulture() {
            const bed = appState.allBeds.find(b => b.id === parseInt(modalBedId.value) && b.type === 'bed');
            
            if (bed && confirm(`Confirmez-vous la cr√©ation d'une NOUVELLE culture sur cet emplacement ? (La culture actuelle sera archiv√©e.)`)) {
                
                const today = new Date().toISOString().split('T')[0];
                
                // Si la date d'arrachage n'est pas d√©finie, on la force √† aujourd'hui avant d'archiver
                if (!bed.harvestDate) {
                    modalHarvestDate.value = today;
                }
                
                saveModification(); // Archivage de l'ancienne culture
                
                const isJachereNew = confirm("üå± Voulez-vous que la prochaine √©tape soit une jach√®re active/un engrais vert ?");
                
                const newBed = {
                    id: Date.now(),
                    type: 'bed', 
                    x: bed.x, 
                    y: bed.y, 
                    w: bed.w, 
                    h: bed.h, 
                    locationKey: bed.locationKey, 

                    name: isJachereNew ? 'Jach√®re/Engrais Vert' : '', 
                    variety: '', 
                    // Si Jach√®re est choisie, on force les bonnes valeurs
                    family: isJachereNew ? JACHERE_FAMILY_KEY : '',
                    isJachere: isJachereNew, 
                    color: isJachereNew ? '#A4C6A4' : '#4CAF50', 
                    icon: isJachereNew ? ICON_MAP['Jach√®re'] : 'ri-seedling-line', 
                    
                    plantingDate: today,
                    harvestDate: '', 
                    stage: CROP_STAGES[0], 
                    notes: 'D√©but de la nouvelle culture.',
                    seeds_plants: '', 
                    harvested_quantity: '', 
                    unit: HARVEST_UNITS[0] 
                };
                
                appState.allBeds.push(newBed);
                saveData();
                render();
                openModal(newBed); // Ouvre la modale sur la nouvelle culture/jach√®re
            }
        }
        
        function renderRotationAdvice(locationKey) {
            const history = appState.allBeds
                .filter(b => b.locationKey === locationKey && b.type === 'bed')
                .sort((a, b) => new Date(b.plantingDate) - new Date(a.plantingDate));
            
            adviceContent.innerHTML = '';

            if (!locationKey) {
                adviceContent.innerHTML = '<p>S√©lectionnez une planche pour afficher les conseils de rotation.</p>';
                return;
            }

            if (history.length === 0) {
                adviceContent.innerHTML = '<p class="advice-ok">Aucun historique. Vous pouvez planter ce que vous voulez !</p>';
                return;
            }
            
            const lastFamily = history[0].isJachere ? JACHERE_FAMILY_KEY : normalizeFamily(history[0].family);
            
            const familiesHistory = history.slice(0, 4) // On ne regarde que les 4 derni√®res rotations
                .map(item => item.isJachere ? JACHERE_FAMILY_KEY : normalizeFamily(item.family))
                .filter(f => f && f !== 'Autre' && f !== JACHERE_FAMILY_KEY); // On ignore les "Autre" et les jach√®res pour le comptage strict

            adviceContent.innerHTML += `<p>Derni√®re culture: **${lastFamily}**</p>`;

            // R√®gle 1: √âviter les familles de la rotation pr√©c√©dente
            const avoidFamilies = ROTATION_RULES[lastFamily] ? ROTATION_RULES[lastFamily].avoid : [];
            if (avoidFamilies.length > 0) {
                 adviceContent.innerHTML += `<div class="advice-danger advice-item">‚ùå **√Ä √âVITER :** ${avoidFamilies.join(', ')} (Rotation imm√©diate non recommand√©e)</div>`;
            }

            // R√®gle 2: Encourager les familles recommand√©es
            const followFamilies = ROTATION_RULES[lastFamily] ? ROTATION_RULES[lastFamily].follow : [];
            if (followFamilies.length > 0) {
                 adviceContent.innerHTML += `<div class="advice-ok advice-item">‚úÖ **RECOMMAND√â :** ${followFamilies.join(', ')} (Bonnes successions)</div>`;
            }

            // R√®gle 3: R√®gle des 4 ans
            const familyCounts = familiesHistory.reduce((acc, family) => {
                acc[family] = (acc[family] || 0) + 1;
                return acc;
            }, {});

            Object.entries(familyCounts).forEach(([family, count]) => {
                if (count > 1) {
                    adviceContent.innerHTML += `<div class="advice-warning advice-item">‚ö†Ô∏è **ALERTE 4 ANS :** La famille ${family} est apparue ${count} fois dans les 4 derni√®res rotations. Une pause d'au moins 3 ans est recommand√©e.</div>`;
                }
            });
            
             // Ajouter un bouton pour mettre la planche en jach√®re
             adviceContent.innerHTML += `<button onclick="proposeJachere('${locationKey}')" style="margin-top: 10px; padding: 8px 15px; background: var(--primary-green); color: white; border: none; border-radius: 4px; cursor: pointer;">Proposer Jach√®re</button>`;
        }
        
        /**
         * Archive la culture actuelle (si pr√©sente) et cr√©e imm√©diatement une nouvelle entr√©e "Jach√®re".
         */
        function proposeJachere(locationKey) {
            const latestBed = appState.allBeds
                .filter(b => b.locationKey === locationKey && b.type === 'bed')
                .sort((a, b) => new Date(b.plantingDate) - new Date(a.plantingDate))[0];
                
            const today = new Date().toISOString().split('T')[0];
                
            if (latestBed) {
                 // 1. Archiver l'ancienne culture si elle n'est pas d√©j√† r√©colt√©e
                 if (!latestBed.harvestDate) {
                     latestBed.harvestDate = today;
                     saveData(); 
                 }
            }
                 
            // 2. Cr√©er la nouvelle entr√©e Jach√®re
            const newBed = {
                id: Date.now(),
                type: 'bed', 
                x: latestBed ? latestBed.x : 0, 
                y: latestBed ? latestBed.y : 0, 
                w: latestBed ? latestBed.w : 50, 
                h: latestBed ? latestBed.h : 50, 
                locationKey: latestBed ? latestBed.locationKey : `${0}_${0}_${50}_${50}_bed`, 

                name: 'Jach√®re/Engrais Vert', 
                variety: '', 
                family: JACHERE_FAMILY_KEY,
                isJachere: true, 
                color: '#A4C6A4', 
                icon: ICON_MAP['Jach√®re'], 
                
                plantingDate: today,
                harvestDate: '', 
                stage: CROP_STAGES[0], 
                notes: 'Initi√©e apr√®s recommandation de rotation.',
                seeds_plants: '', 
                harvested_quantity: '', 
                unit: HARVEST_UNITS[0] 
            };
            
            appState.allBeds.push(newBed);
            saveData();
            render();
            
            // 3. Ouvre la modale sur la nouvelle planche Jach√®re pour la configurer (ex: date de fin)
            openModal(newBed); 
        }
        
        function renderCalendar() {
            calendarList.innerHTML = '';
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const futureEvents = appState.allBeds
                .filter(b => b.type === 'bed' && b.harvestDate) // On ne veut que les planches qui ont une date de r√©colte *pr√©vue*
                .map(b => ({
                    date: new Date(b.harvestDate),
                    name: b.name,
                    family: b.isJachere ? JACHERE_FAMILY_KEY : normalizeFamily(b.family),
                    w: b.w,
                    h: b.h,
                    locationKey: b.locationKey,
                    stage: b.stage
                }))
                .filter(e => e.date.getTime() >= today.getTime()) // Seulement les √©v√©nements futurs ou d'aujourd'hui
                .sort((a, b) => a.date - b.date)
                .slice(0, 5); // Afficher les 5 prochains √©v√©nements

            if (futureEvents.length === 0) {
                calendarList.innerHTML = '<li class="calendar-item">Aucune r√©colte ou fin de culture pr√©vue bient√¥t.</li>';
                return;
            }

            futureEvents.forEach(event => {
                const li = document.createElement('li');
                li.className = 'calendar-item';
                
                const daysUntil = Math.ceil((event.date.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                const color = daysUntil < 30 ? 'var(--color-red)' : daysUntil < 90 ? 'var(--color-yellow)' : 'var(--primary-green)';

                li.innerHTML = `
                    <strong style="color: ${color};">${event.name} (${event.family}) - Fin pr√©vue</strong>
                    <span>**Date:** ${formatDate(event.date.toISOString().split('T')[0])} (${daysUntil} jours)</span>
                    <span>**Emplacement:** ${event.w} x ${event.h} px</span>
                    <small>Pr√©voir l'arrachage et la succession de culture.</small>
                `;
                calendarList.appendChild(li);
            });
        }
        
        function renderGlobalStats() {
            statsSummary.innerHTML = '';
            
            const filterDateString = dateFilter.value;
            const selectedDate = filterDateString ? new Date(filterDateString) : new Date();
            selectedDate.setHours(0, 0, 0, 0);

            // Filtrer les planches actives √† la date s√©lectionn√©e
            const activeBeds = appState.allBeds.filter(b => {
                if (b.type !== 'bed') return false;
                
                const planting = b.plantingDate ? new Date(b.plantingDate) : null;
                if (planting) planting.setHours(0, 0, 0, 0);
                
                const harvest = b.harvestDate ? new Date(b.harvestDate) : null;
                if (harvest) harvest.setHours(0, 0, 0, 0);

                const planted = planting && planting.getTime() <= selectedDate.getTime();
                const notHarvested = !harvest || harvest.getTime() > selectedDate.getTime();
                
                return planted && notHarvested;
            });

            // Calculer la surface totale
            const totalArea = activeBeds.reduce((sum, b) => sum + (b.w * b.h), 0);
            
            // Compter par famille
            const familyCount = activeBeds.reduce((acc, b) => {
                const family = b.isJachere ? JACHERE_FAMILY_KEY : normalizeFamily(b.family);
                acc[family] = (acc[family] || { count: 0, area: 0 });
                acc[family].count++;
                acc[family].area += (b.w * b.h);
                return acc;
            }, {});
            
            // D√©terminer la famille la plus pr√©sente
            let maxFamily = { name: 'Aucune', area: 0 };
            Object.entries(familyCount).forEach(([name, data]) => {
                if (data.area > maxFamily.area) {
                    maxFamily.name = name;
                    maxFamily.area = data.area;
                }
            });
            
            // Statistiques par familles (pour la barre d'info)
            const topFamilyDisplay = activeBeds.length > 0 
                ? `${maxFamily.name} (${((maxFamily.area / totalArea) * 100).toFixed(0)}%)` 
                : 'N/A';
                
            // Nombre de barri√®res / lignes
            const lineCount = appState.allBeds.filter(b => b.type === 'line').length;

            statsSummary.innerHTML = `
                <div class="stat-card">
                    <strong>${activeBeds.length}</strong>
                    <small>Planches Actives</small>
                </div>
                <div class="stat-card">
                    <strong>${totalArea.toFixed(0)} px¬≤</strong>
                    <small>Surface Cultiv√©e Totale</small>
                </div>
                <div class="stat-card">
                    <strong>${topFamilyDisplay}</strong>
                    <small>Famille Majoritaire</small>
                </div>
                 <div class="stat-card">
                    <strong>${lineCount}</strong>
                    <small>Barri√®res/All√©es</small>
                </div>
            `;
        }

        // --- RENDU (AFFICHAGE) ---
        
        // Fonction utilitaire pour calculer la transformation d'une ligne
        function calculateLineStyle(x1, y1, x2, y2) {
            const length = generateDistance(x1, y1, x2, y2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
            return { length, angle };
        }
        
        // Mise √† jour visuelle d'une ligne (utilis√©e dans move/resize et render)
        function updateLineElement(line) {
             const { x: x1, y: y1 } = line.points[0];
             const { x: x2, y: y2 } = line.points[1];
             const { length, angle } = calculateLineStyle(x1, y1, x2, y2);

             const lineEl = document.querySelector(`.garden-element[data-bed-id="${line.id}"]`);
             if (lineEl) {
                 lineEl.style.left = `${x1}px`;
                 lineEl.style.top = `${y1}px`;
                 lineEl.style.width = `${length}px`;
                 lineEl.style.transform = `rotate(${angle}deg)`;
                 const nameSpan = lineEl.querySelector('.line-name');
                 if (nameSpan) nameSpan.textContent = `${line.name} (${length.toFixed(1)} px)`;
             }
        }

        function render() {
            renderGlobalStats();

            const existingElements = canvas.querySelectorAll('.garden-element');
            existingElements.forEach(el => el.remove());

            const filterDateString = dateFilter.value;
            const selectedDate = filterDateString ? new Date(filterDateString) : null;
            let filterDateNormalized = null;
            if (selectedDate) {
                filterDateNormalized = new Date(selectedDate);
                filterDateNormalized.setHours(0, 0, 0, 0);
            }

            appState.allBeds.forEach(element => {
                
                if (element.type === 'bed') {
                    
                    let shouldDraw = true;
                    if (filterDateNormalized) {
                        const plantingDate = element.plantingDate ? new Date(element.plantingDate) : null;
                        if (plantingDate) plantingDate.setHours(0, 0, 0, 0);

                        const harvestDate = element.harvestDate ? new Date(element.harvestDate) : null;
                        if (harvestDate) harvestDate.setHours(0, 0, 0, 0);

                        if (!plantingDate || plantingDate.getTime() > filterDateNormalized.getTime()) {
                            shouldDraw = false; 
                        }
                        if (harvestDate && harvestDate.getTime() <= filterDateNormalized.getTime()) {
                            shouldDraw = false; 
                        }
                    } else {
                        // Pas de filtre: n'afficher que les cultures actives (non r√©colt√©es)
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const harvestDate = element.harvestDate ? new Date(element.harvestDate) : null;
                        if (harvestDate && harvestDate.getTime() < today.getTime()) {
                             shouldDraw = false; 
                        }
                    }

                    if (shouldDraw) {
                        drawBed(element);
                    }
                } 
                else if (element.type === 'line') {
                    drawLine(element);
                }
            });
            
            renderCalendar(); 
            renderRotationAdvice(null); // R√©initialiser le conseil
        }
        
        // --- FONCTIONS DE CR√âATION D'√âL√âMENTS ---

        function createBed(x, y, w, h) {
            const name = prompt("üå± Qu'allez-vous cultiver ici ? (Laissez vide pour Jach√®re)") || '';
            const isJachere = (name.trim() === "");
            
            const finalName = isJachere ? 'Jach√®re/Engrais Vert' : name.trim();
            const finalFamily = isJachere ? JACHERE_FAMILY_KEY : (modalFamily.value || '');
            const finalColor = isJachere ? '#A4C6A4' : (modalColor.value || '#4CAF50');
            const finalIcon = isJachere ? ICON_MAP['Jach√®re'] : (modalIconValue.value || 'ri-seedling-line');

            const today = new Date().toISOString().split('T')[0];
            const defaultStage = CROP_STAGES[0]; 

            const newBed = {
                id: Date.now(),
                type: 'bed',
                x: x, y: y, w: w, h: h,
                locationKey: `${x}_${y}_${w}_${h}_bed`,
                name: finalName,
                isJachere: isJachere,
                variety: '', 
                family: finalFamily,
                color: finalColor,
                icon: finalIcon, 
                
                plantingDate: today,
                harvestDate: '', 
                stage: defaultStage, 
                notes: '',
                seeds_plants: '', 
                harvested_quantity: '', 
                unit: HARVEST_UNITS[0] 
            };
            appState.allBeds.push(newBed);
            saveData();
            render();
            openModal(newBed); // Ouvre la modale pour la configuration
        }
        
        function createLine(x1, y1, x2, y2) {
            const name = prompt("üöß Nommez cette ligne (All√©e, Irrigation, Bordure) :") || "All√©e";
            if (name) {
                const newLine = {
                    id: Date.now(),
                    type: 'line',
                    points: [{x: x1, y: y1}, {x: x2, y: y2}],
                    locationKey: getLocationKey({type: 'line', points: [{x: x1, y: y1}, {x: x2, y: y2}]}),
                    name: name.trim(),
                };
                appState.allBeds.push(newLine); 
                saveData();
                render();
                openBarrierModal(newLine); // Ouvre la modale pour la configuration
            }
        }
        
        function drawLine(line) {
            const lineEl = document.createElement('div');
            lineEl.className = 'garden-element garden-line';
            lineEl.dataset.bedId = line.id; 
            lineEl.dataset.locationKey = getLocationKey(line); 
            
            const { length, angle } = calculateLineStyle(line.points[0].x, line.points[0].y, line.points[1].x, line.points[1].y);
            
            lineEl.innerHTML = `
                <span class="line-name">${line.name} (${length.toFixed(1)} px)</span>
                <div class="line-handle start"></div>
                <div class="line-handle end"></div>
            `;
            
            lineEl.style.left = `${line.points[0].x}px`;
            lineEl.style.top = `${line.points[0].y}px`;
            lineEl.style.width = `${length}px`;
            lineEl.style.transform = `rotate(${angle}deg)`;
            
            lineEl.addEventListener('dblclick', (e) => {
                e.stopPropagation(); 
                openBarrierModal(line);
            });
            
            canvas.appendChild(lineEl);
        }

        function drawBed(bed) {
            const bedEl = document.createElement('div');
            // Ajout de la classe is-jachere si l'option est coch√©e
            bedEl.className = `garden-element garden-bed ${bed.isJachere ? 'is-jachere' : ''}`;
            bedEl.dataset.bedId = bed.id; 
            bedEl.dataset.locationKey = getLocationKey(bed); 
            
            const bedFamily = bed.isJachere ? JACHERE_FAMILY_KEY : (bed.family && bed.family !== '' ? bed.family : 'N/A');
            const varietyDisplay = bed.variety ? `(${bed.variety})` : '';
            
            let quantityDisplay = '';
            if (bed.seeds_plants && bed.seeds_plants > 0) {
                quantityDisplay = `<span class="bed-quantity">Qt√©: ${bed.seeds_plants}</span>`;
            }
            
            const stageDisplay = bed.stage ? `<span class="bed-stage">${bed.stage}</span>` : '';


            bedEl.innerHTML = `
                <div class="bed-content" style="background-color: ${bed.isJachere ? 'transparent' : bed.color};">
                    <i class="${bed.icon || 'ri-seedling-line'} bed-icon"></i>
                    <span class="bed-name">${bed.name} ${varietyDisplay}</span>
                    <span class="bed-family">${bed.isJachere ? 'JACH√àRE (Am√©liorante)' : bedFamily}</span>
                    ${quantityDisplay}
                    ${stageDisplay} 
                    <span class="bed-dimensions">${bed.w} x ${bed.h} px</span>
                </div>
                <div class="resizer top-left"></div>
                <div class="resizer top-right"></div>
                <div class="resizer bottom-left"></div>
                <div class="resizer bottom-right"></div>
            `;
            
            bedEl.style.backgroundColor = bed.isJachere ? bed.color : bed.color; 
            bedEl.style.left = `${bed.x}px`;
            bedEl.style.top = `${bed.y}px`;
            bedEl.style.width = `${bed.w}px`;
            bedEl.style.height = `${bed.h}px`;

            // Ajout de l'√©couteur d'√©v√©nement pour le clic et double-clic
            bedEl.addEventListener('click', (e) => {
                if (isResizing || e.target.classList.contains('resizer')) {
                     e.stopPropagation();
                     return;
                }
                
                if (clickTimeout !== null) {
                    clearTimeout(clickTimeout);
                    clickTimeout = null;
                    openModal(bed); // Double-clic
                    return;
                }
                
                clickTimeout = setTimeout(() => {
                    if (clickTimeout !== null) {
                        openHistoryModal(bed); // Simple clic
                        renderRotationAdvice(bedEl.dataset.locationKey);
                        clickTimeout = null;
                    }
                }, 250);
                
                e.stopPropagation();
            });
            
            // Pour √™tre s√ªr, on ajoute aussi le dblclick direct au cas o√π le timeout ne fonctionne pas
            bedEl.addEventListener('dblclick', (e) => {
                e.stopPropagation(); 
                clearTimeout(clickTimeout);
                clickTimeout = null;
                openModal(bed);
            });


            canvas.appendChild(bedEl);
        }

        // --- LOGIQUE DE REDIMENSIONNEMENT DES PLANCHES (BED) ---
        function startResizeBed(e) {
            isResizing = true;
            e.stopPropagation(); 
            const elementEl = e.target.closest('.garden-element');
            const elementId = parseInt(elementEl.dataset.bedId);
            activeElement = appState.allBeds.find(b => b.id === elementId && b.type === 'bed');
            
            const rect = canvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            
            activeElement.initialX = activeElement.x;
            activeElement.initialY = activeElement.y;
            activeElement.initialW = activeElement.w;
            activeElement.initialH = activeElement.h;
            
            resizeHandleType = e.target.className.split(' ').find(cls => cls.includes('-')).replace('resizer', '').trim();
        }

        function performResizeBed(currentX, currentY) {
            if (!activeElement || activeElement.type !== 'bed') return;
            const dx = currentX - startX;
            const dy = currentY - startY;
            let newX = activeElement.initialX;
            let newY = activeElement.initialY;
            let newW = activeElement.initialW;
            let newH = activeElement.initialH;
            
            // Logique de redimensionnement
            if (resizeHandleType.includes('right')) { newW = Math.max(30, activeElement.initialW + dx); }
            if (resizeHandleType.includes('left')) { newW = Math.max(30, activeElement.initialW - dx); if (newW > 30) { newX = activeElement.initialX + dx; } }
            if (resizeHandleType.includes('bottom')) { newH = Math.max(30, activeElement.initialH + dy); }
            if (resizeHandleType.includes('top')) { newH = Math.max(30, activeElement.initialH - dy); if (newH > 30) { newY = activeElement.initialY + dy; } }
            
            activeElement.x = newX;
            activeElement.y = newY;
            activeElement.w = newW;
            activeElement.h = newH;
            
            const elementEl = document.querySelector(`.garden-element[data-bed-id="${activeElement.id}"]`);
            if (elementEl) {
                elementEl.style.left = `${newX}px`;
                elementEl.style.top = `${newY}px`;
                elementEl.style.width = `${newW}px`;
                elementEl.style.height = `${newH}px`;
                const dimSpan = elementEl.querySelector('.bed-dimensions');
                if(dimSpan) dimSpan.textContent = `${newW} x ${newH} px`;
            }
        }
        
        // --- LOGIQUE DE D√âPLACEMENT/REDIMENSIONNEMENT DES LIGNES ---
        function startMoveOrResizeLine(e) {
            isMovingLine = true;
            e.stopPropagation();
            const elementEl = e.target.closest('.garden-element');
            const elementId = parseInt(elementEl.dataset.bedId);
            activeElement = appState.allBeds.find(b => b.id === elementId && b.type === 'line');

            const rect = canvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            
            activeElement.initialP0 = { ...activeElement.points[0] };
            activeElement.initialP1 = { ...activeElement.points[1] };
            
            // D√©termine si on resize (poign√©e) ou d√©place (corps de la ligne)
            if (e.target.classList.contains('line-handle')) {
                 resizeHandleType = e.target.classList.contains('start') ? 'start' : 'end';
            } else {
                 resizeHandleType = 'move';
            }
        }

        function performMoveOrResizeLine(currentX, currentY) {
            if (!activeElement || activeElement.type !== 'line') return;
            const dx = currentX - startX;
            const dy = currentY - startY;

            if (resizeHandleType === 'move') {
                // D√©placement complet de la ligne
                activeElement.points[0].x = activeElement.initialP0.x + dx;
                activeElement.points[0].y = activeElement.initialP0.y + dy;
                activeElement.points[1].x = activeElement.initialP1.x + dx;
                activeElement.points[1].y = activeElement.initialP1.y + dy;
            } else {
                // Redimensionnement √† partir d'une extr√©mit√©
                const targetPointIndex = resizeHandleType === 'start' ? 0 : 1;
                const initialPoint = targetPointIndex === 0 ? activeElement.initialP0 : activeElement.initialP1;
                
                activeElement.points[targetPointIndex].x = initialPoint.x + dx;
                activeElement.points[targetPointIndex].y = initialPoint.y + dy;
            }
            // Mise √† jour visuelle (sans re-rendu complet pour la fluidit√©)
            updateLineElement(activeElement);
        }

        // Lancement au chargement de la page
        init();
    </script>
</body>
</html>
